<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="书山有路勤为径，学海无涯苦作舟">
<meta property="og:type" content="website">
<meta property="og:title" content="Code King&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Code King&#39;s Blog">
<meta property="og:description" content="书山有路勤为径，学海无涯苦作舟">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bjy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Code King's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Code King's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">冒泡排序</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-17 14:40:00 / 修改时间：15:02:31" itemprop="dateCreated datePublished" datetime="2022-01-17T14:40:00+08:00">2022-01-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">排序算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>816</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a><strong>冒泡排序</strong>(Bubble Sort)</h2><p>冒泡排序(Bubble Sort)是一种常用的排序算法。总体是思路是每次取当前未排序子序列的最后一个元素，然后对前面所有元素进行遍历，如果当前元素大于最后一个元素，就交换两者的位置，这样一次循环后，得到的最后一个元素就是当前最大的元素，然后将未排序序列的末尾往前移动即可。flag则是在每次循环中判断是否存在交换，如果不存在交换，则说明序列已经是有序序列，则退出循环即可。冒泡排序的平均以及最坏情况的时间复杂度均为 $O(n^2)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j] &lt; v[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(v[j<span class="number">-1</span>],v[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BubbleSort</span>(v,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/12/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/12/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/" class="post-title-link" itemprop="url">关键路径</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-12 13:28:00 / 修改时间：14:15:50" itemprop="dateCreated datePublished" datetime="2021-12-12T13:28:00+08:00">2021-12-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构——图</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这样以有向边表示活动的网称为AOE网。拓扑排序是对有向无环图而言的。从源点到汇点对整个项目的工期具有决定性作用的工序所代表的的路径叫做关键路径。关键路径可能不止一条。</p>
<h2 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h2><p>只需找到每条工序的最早完成时间和最晚开始时间，如果一条有向边的终点的最晚开始时间和起点的最早完成时间之差为这条边的权重，那么这条边为关键路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(Graph g)</span></span>&#123;  <span class="comment">//图中包含邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> n = g.numvex;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//存储顶点的入度个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">outdegree</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//存储顶点的出度个数</span></span><br><span class="line">    <span class="built_in">Initial</span>(indegree);</span><br><span class="line">    <span class="built_in">Initial</span>(outdegree);</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">eartime</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;  <span class="comment">//工序的最早完成时间</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">Visit</span>(x);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.adj[x][i] &lt; INF)&#123;</span><br><span class="line">                <span class="keyword">if</span>(eartime[x] + g.adj[x][i] &gt; eartime[i])&#123;</span><br><span class="line">                    <span class="comment">//最早完成时间是所有前导工序完成时间的最大值</span></span><br><span class="line">                    eartime[i] = eartime[x] + g.adj[x][i];</span><br><span class="line">                &#125;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>; <span class="comment">//存在环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> earfinish = <span class="number">0</span>; <span class="comment">//整个工序完成的最短时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//整个工序完成时间是最晚的那个工序完成的时间</span></span><br><span class="line">        earfinish = <span class="built_in">max</span>(earfinish,eartime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lattime</span><span class="params">(n+<span class="number">1</span>,earfinish)</span></span>;  <span class="comment">//工序的最晚开始时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i-++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(outdegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.adj[i][x] &lt; INF)&#123;               </span><br><span class="line">                <span class="keyword">if</span>(lattime[x] - g.adj[i][x] &lt; lattime[i])&#123;</span><br><span class="line">                    <span class="comment">//一个工序的最晚开始时间是后序工序需要的开始时间中最早的那个</span></span><br><span class="line">                    lattime[i] = lattime[x] - g.adj[i][x];</span><br><span class="line">                &#125;                </span><br><span class="line">                outdegree[i]--;</span><br><span class="line">                <span class="keyword">if</span>(outdegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.adj[i][j] &lt; INF &amp;&amp; lattime[j] - eartime[i] == g.adj[i][j])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%d\n&quot;</span>,i,j);   <span class="comment">//是关键路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/10/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">拓扑排序</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-10 20:36:00" itemprop="dateCreated datePublished" datetime="2021-12-10T20:36:00+08:00">2021-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-16 10:35:00" itemprop="dateModified" datetime="2022-01-16T10:35:00+08:00">2022-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构——图</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>712</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>在一个表示工程的有向图中，用顶点表示活动，用有向边表示活动之间的先后关系，这样以顶点表示活动的网称为AOV网。拓扑排序是对有向无环图而言的。对一个有向无环图构造一个具有先后次序的序列的过程即为拓扑排序。</p>
<h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><p>首先计算每个顶点的入度。构造一个队列，将开始入度为0的顶点入队。然后在队列不空时开始循环，每次弹出一个元素，对它进行访问，并且对它所有的出度边的终点的入度减1，并将入度为0的结点入队。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopSort</span><span class="params">(Graph g)</span></span>&#123;  <span class="comment">//图中包含邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> n = g.numvex;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//存储每个结点的入度</span></span><br><span class="line">    <span class="built_in">Initial</span>(indegree);</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">Visit</span>(x);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[x][i] &lt; INF)&#123;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>; <span class="comment">//存在环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" class="post-title-link" itemprop="url">最短路径算法</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-10 16:28:00 / 修改时间：16:52:36" itemprop="dateCreated datePublished" datetime="2021-12-10T16:28:00+08:00">2021-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构——图</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径是对一个无负权边的有权图而言的。求最短路径指求一个结点到另一个结点经过的边上的权值之和的最小的路径。</p>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>Dijkstra算法也是一个非常典型的贪心算法。Dijkstra算法和求最小生成树中的Prim算法非常相似，Dijkstra算法也是从某一个结点出发，每次寻找距离起点最小距离的结点，访问这个结点的同时更新这个结点所有邻接点到起点的距离，直到所有结点都已被访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Dijkstra</span><span class="params">(Graph g,<span class="keyword">int</span> start,vector&lt;<span class="keyword">int</span>&gt;&amp; minpath,vector&lt;<span class="keyword">int</span>&gt;&amp; pathvex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//g中包括图的顶点数和边数以及一个邻接矩阵，minpath存储起点到各个结点的最短路径的值</span></span><br><span class="line">    <span class="comment">//pathvex存储每个结点的前驱结点，可以通过前驱结点反向推出最短路径</span></span><br><span class="line">    <span class="keyword">int</span> n = g.numvex;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        minpath[i] = g.adj[start][i];</span><br><span class="line">        minvex[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;  <span class="comment">//每次循环收入一个结点</span></span><br><span class="line">        <span class="keyword">int</span> dmin = INF;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;  <span class="comment">//找到当前距离起点最短的那个结点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag[j] &amp;&amp; minpath[j] &lt; dmin)&#123;</span><br><span class="line">                dmin = minpath[j];</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[idx] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;  <span class="comment">//更新新收入这个结点的所有未收入邻接点的距离</span></span><br><span class="line">            <span class="keyword">if</span>(!flag[j] &amp;&amp; dmin + g.adj[idx][j] &lt; minpath[j])&#123;</span><br><span class="line">                minpath[j] = dmin + g.adj[idx][j];</span><br><span class="line">                minvex[j] = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>Floyd算法用来求所有顶点到所有顶点的最短路径，并且在算法实现上非常简洁明了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(Graph g,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; minpath,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; pathvex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g.numvex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            minpath[i][j] = g.adj[i][j];  <span class="comment">//初始化为邻接矩阵</span></span><br><span class="line">            pathvex[i][j] = j;  <span class="comment">//初始化为列下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(minpath[i][k] + minpath[k][j] &lt; minpath[i][j])&#123;</span><br><span class="line">                    <span class="comment">//如果经过k的路径比原来两点之间的路径小</span></span><br><span class="line">                    minpath[i][j] = minpath[i][k] + minpath[k][j]; <span class="comment">//更新最短路径</span></span><br><span class="line">                    pathvex[i][j] = pathvex[i][k];  <span class="comment">//路径设为经过下标k的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="post-title-link" itemprop="url">最小生成树算法</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-10 15:44:00" itemprop="dateCreated datePublished" datetime="2021-12-10T15:44:00+08:00">2021-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-16 10:31:18" itemprop="dateModified" datetime="2022-01-16T10:31:18+08:00">2022-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构——图</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h1><p>一个连通图的生成树是一个极小的连通子图，通过图中的 $n-1$ 条边将图中的 $n$ 个结点连接成一棵树。最小生成树是对有权图而言的。当这些边的权值之和最小时，得到的生成树就是最小生成树。</p>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim算法是一个典型的贪心算法。从某一个顶点开始循环，每次将生成树外距离生成树最近的一个顶点收入生成树中，并且更新这个顶点的邻接点距离当前生成树的距离，直到所有顶点都被收入生成树中后停止循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrimForMST</span><span class="params">(Graph g)</span></span>&#123;  <span class="comment">//传入一个图，包含图的顶点数、边数和邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> n = g.numVex;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mincost</span><span class="params">(n)</span></span>;  <span class="comment">//当前的生成树到每个顶点的最小距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">adjvex</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//当前生成树到每个顶点最小距离的顶点下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        mincost[i] = g.adj[<span class="number">0</span>][i];  <span class="comment">//当前生成树只有一个结点v0，因此距离为第一行的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dmin = INF;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;  <span class="comment">//找到当前距离生成树最小的一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(mincost[j] &amp;&amp; mincost[j] &lt; dmin)&#123;</span><br><span class="line">                dmin = mincost[j];</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,adjvex[idx],idx);  <span class="comment">//打印收入结点的路径</span></span><br><span class="line">        mincost[idx] = <span class="number">0</span>;  <span class="comment">//将这个结点收入生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i &lt; n; j++)&#123;  <span class="comment">//更新结点的最小距离</span></span><br><span class="line">            <span class="keyword">if</span>(mincost[j] &amp;&amp; gph.adj[idx][j] &lt; mincost[j])&#123; </span><br><span class="line">                <span class="comment">//当前结点未在生成树中，并且当前收入的结点到这个结点的距离小于之前的距离</span></span><br><span class="line">                mincost[j] = gph.adj[idx][j];  <span class="comment">//更新这个结点的最小距离</span></span><br><span class="line">                adjvex[j] = idx;  <span class="comment">//更新树中到这个结点最小距离的结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>Kruskal算法也是一个典型的贪心算法。我们将图中所有边的权重进行从小到大的排序，每次判断两侧的结点是否已在同一集合中，如果不在，就访问这条边的两个结点，将结点收入生成树中，继续循环，直到所有的结点都被收入生成树中。在算法中，使用边集数组来存储图结构，使用最小堆来取出权值最小的边，使用并查集判断结点是否在同一个集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id1;</span><br><span class="line">    <span class="keyword">int</span> id2;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(vector&lt;Edge&gt;&amp;edge,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//调整最小堆</span></span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span>*start;</span><br><span class="line">    edge[<span class="number">0</span>] = edge[start];</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= end)&#123;  </span><br><span class="line">    <span class="comment">//每次循环将当前不正确的结点与两个子结点中较小的进行比较，如果小于子结点，则保持不动，退出循环；</span></span><br><span class="line">    <span class="comment">//否则交换位置，继续向下层判断，直到放到正确的位置</span></span><br><span class="line">        <span class="keyword">if</span>(child &lt; end &amp;&amp; edge[child+<span class="number">1</span>].weight &lt; edge[child].weight)&#123; </span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edge[<span class="number">0</span>].weight &lt;= edge[child].weight)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edge[start] = edge[child];</span><br><span class="line">        start = child;</span><br><span class="line">        child *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    edge[start] = edge[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;Edge&gt;&amp; edge,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i++)&#123;  <span class="comment">//n/2是第一个存在子结点的中间结点，索引0为哨兵，下标从1开始</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(edge,i,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fa,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;  <span class="comment">//小于0表示当前结点为根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">Find</span>(fa,fa[x]);  <span class="comment">//否则进行递归，找到当前结点的根结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fa,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fa数组初始化为-1，负的数值表示当前集合的规模，如果为正表示当前结点的父结点的下标</span></span><br><span class="line">    <span class="keyword">if</span>(fa[x] &lt; fa[y])&#123;  <span class="comment">//将较小的并入较大的</span></span><br><span class="line">        fa[x] += fa[y];</span><br><span class="line">        fa[y] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fa[y] += fa[x];</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KruskalForMST</span><span class="params">(Graph g)</span></span>&#123;  <span class="comment">//图由边集数组存储，包含两侧的结点下标以及边的权重</span></span><br><span class="line">    <span class="keyword">int</span> n = g.numvex;</span><br><span class="line">    <span class="keyword">int</span> m = g.numedge;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">fa</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v = g.edge;</span><br><span class="line">    <span class="built_in">BuildHeap</span>(v,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(v[<span class="number">1</span>],v.<span class="built_in">back</span>());</span><br><span class="line">        Edge e = v.<span class="built_in">back</span>();</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">AdjustHeap</span>(v,<span class="number">1</span>,m-i);</span><br><span class="line">        <span class="keyword">int</span> root1 = <span class="built_in">Find</span>(fa,e.id1);</span><br><span class="line">        <span class="keyword">int</span> root2 = <span class="built_in">Find</span>(fa,e.id2);</span><br><span class="line">        <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">            <span class="built_in">Union</span>(fa,root1,root2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) %d\n&quot;</span>,e.id1,e.id2,e.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/09/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">Graph Traversal</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-09 22:02:00" itemprop="dateCreated datePublished" datetime="2021-12-09T22:02:00+08:00">2021-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-15 17:33:42" itemprop="dateModified" datetime="2022-01-15T17:33:42+08:00">2022-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构——图</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图的遍历-Graph-Traversal"><a href="#图的遍历-Graph-Traversal" class="headerlink" title="图的遍历(Graph Traversal)"></a>图的遍历(Graph Traversal)</h1><p>图的遍历是从图中某一个结点处出发，对图中的每一个结点进行访问操作，并且每一个结点都只<strong>访问一次</strong>。</p>
<h2 id="1-图的深度优先遍历-DFS"><a href="#1-图的深度优先遍历-DFS" class="headerlink" title="1 图的深度优先遍历(DFS)"></a>1 图的深度优先遍历(DFS)</h2><h3 id="1-1-基于邻接矩阵的深度优先遍历"><a href="#1-1-基于邻接矩阵的深度优先遍历" class="headerlink" title="1.1 基于邻接矩阵的深度优先遍历"></a>1.1 基于邻接矩阵的深度优先遍历</h3><p>邻接矩阵中存储了图中各个结点直接的相邻关系。在无权图中，邻接矩阵中存储的值表示这两个顶点之间是否存在无向边，有边时值为1，无边时值为0；在有权图中，邻接矩阵中的值表示两个顶点之间无向边的权值，一般将其余值赋为正无穷。我们很容易看出对于无向图而言，邻接矩阵是一个对称矩阵，而在有向图中，邻接矩阵则不是对称矩阵。在深度优先遍历时，我们只需要在访问一个结点的同时，对它所有的邻接点进行递归遍历即可。</p>
<h4 id="无权图版本"><a href="#无权图版本" class="headerlink" title="无权图版本"></a>无权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adj,<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i] &amp;&amp; adj[idx][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">adj</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>)); <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        adj[x][y] = <span class="number">1</span>;</span><br><span class="line">        adj[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有权图版本"><a href="#有权图版本" class="headerlink" title="有权图版本"></a>有权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adj,<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i] &amp;&amp; adj[idx][i] != INF)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">adj</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,INF)); <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边及其权值</span></span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        adj[x][y] = w;</span><br><span class="line">        adj[y][x] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-基于邻接表的深度优先遍历"><a href="#1-2-基于邻接表的深度优先遍历" class="headerlink" title="1.2 基于邻接表的深度优先遍历"></a>1.2 基于邻接表的深度优先遍历</h3><p>邻接表对于每一个顶点都存储了每个顶点的邻接点，在遍历时，我们只需要在访问这个结点的同时递归访问它的邻接点即可。</p>
<h4 id="无权图版本-1"><a href="#无权图版本-1" class="headerlink" title="无权图版本"></a>无权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; adj[],<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[idx].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[adj[idx][i]])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,adj[idx][i],visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; adj[n]; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        adj[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        adj[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有权图版本-1"><a href="#有权图版本-1" class="headerlink" title="有权图版本"></a>有权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> vexid;</span><br><span class="line">    Edge* next;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> id,<span class="keyword">int</span> w)&#123;</span><br><span class="line">        vexid = id;</span><br><span class="line">        weight = w;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    Edge* firstedge = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; adj[],<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    Edge* p;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;vexid])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,p-&gt;vexid,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    <span class="function">vector&lt;Vertex&gt; <span class="title">adj</span><span class="params">(n)</span></span>; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        Edge* edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(y,w);</span><br><span class="line">        edge-&gt;next = adj[x]-&gt;firstedge;</span><br><span class="line">        adj[x]-&gt;firstedge = edge;</span><br><span class="line">        edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(x,w);</span><br><span class="line">        edge-&gt;next = adj[y]-&gt;firstedge;</span><br><span class="line">        adj[y]-&gt;firstedge = edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-图的广度优先遍历-BFS"><a href="#2-图的广度优先遍历-BFS" class="headerlink" title="2 图的广度优先遍历(BFS)"></a>2 图的广度优先遍历(BFS)</h2><p>使用一个队列，每访问一个一个结点就将它未访问的邻接点推入队列中即可。需要注意的是，在邻接点推入队列时就需要对这个点进行访问，而不能在出队列时才进行访问，否则会出现这个结点在队列中多次出现的情况导致结果的错误。</p>
<h3 id="2-1-基于邻接矩阵的广度优先遍历"><a href="#2-1-基于邻接矩阵的广度优先遍历" class="headerlink" title="2.1 基于邻接矩阵的广度优先遍历"></a>2.1 基于邻接矩阵的广度优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">adj</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>)); <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        adj[x][y] = <span class="number">1</span>;</span><br><span class="line">        adj[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Visit</span>(i);</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[j] &amp;&amp; adj[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(j);</span><br><span class="line">                        visited[j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">Visit</span>(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-基于邻接表的广度优先遍历"><a href="#2-2-基于邻接表的广度优先遍历" class="headerlink" title="2.2 基于邻接表的广度优先遍历"></a>2.2 基于邻接表的广度优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vexid;</span><br><span class="line">    Edge* next;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> id)&#123;</span><br><span class="line">        vexid = id;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    Edge* firstedge = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    <span class="function">vector&lt;Vertex&gt; <span class="title">adj</span><span class="params">(n)</span></span>; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        Edge* edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(y);</span><br><span class="line">        edge-&gt;next = adj[x]-&gt;firstedge;</span><br><span class="line">        adj[x]-&gt;firstedge = edge;</span><br><span class="line">        edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(x);</span><br><span class="line">        edge-&gt;next = adj[y]-&gt;firstedge;</span><br><span class="line">        adj[y]-&gt;firstedge = edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Visit</span>(i);</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                Edge* p = adj[x]-&gt;firstedge;</span><br><span class="line">                <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[p-&gt;vexid])&#123;</span><br><span class="line">                        visited[p-&gt;vexid] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">Visit</span>(p-&gt;vexid);</span><br><span class="line">                        q.<span class="built_in">push</span>(p-&gt;vexid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/All-possible-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/All-possible-tree/" class="post-title-link" itemprop="url">LeetCode 894. All Possible Full Binary Trees</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 15:57:00 / 修改时间：15:56:12" itemprop="dateCreated datePublished" datetime="2021-11-15T15:57:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-894-All-Possible-Full-Binary-Trees"><a href="#LeetCode-894-All-Possible-Full-Binary-Trees" class="headerlink" title="LeetCode 894. All Possible Full Binary Trees"></a>LeetCode 894. All Possible Full Binary Trees</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.      </p>
<p>Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.      </p>
<p>A full binary tree is a binary tree where each node has exactly 0 or 2 children.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>n = 7</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>n = 3</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>[[0,0,0]]
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= n &lt;= 20</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个整数n，输出由n个结点组成的所有可能的二叉树，这个二叉树必须满足每个结点都有0个或者2个子结点，每个结点的值都为0。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于每个结点都有0个或者2个子结点，故n一定为奇数，所以按照从小到大的顺序进行遍历，设左侧结点数为i，递归调用函数建立子树，右侧同理，然后接到当前的根结点上即可建立一棵符合条件的二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;  <span class="comment">//边界条件，如果只有一个结点，就创建然后返回</span></span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">            v.<span class="built_in">push_back</span>(node);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i += <span class="number">2</span>)&#123;  <span class="comment">//遍历所有可能情况，左侧结点为i个，右侧结点为n-i-1个</span></span><br><span class="line">            vector&lt;TreeNode*&gt; left = <span class="built_in">allPossibleFBT</span>(i);  <span class="comment">//递归建立左子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; right = <span class="built_in">allPossibleFBT</span>(n-i<span class="number">-1</span>);  <span class="comment">//递归建立右子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; left.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; right.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="comment">//从左右子树取出任意一个作为根结点，然后接在当前这个根结点上</span></span><br><span class="line">                    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                    node-&gt;left = left[j];</span><br><span class="line">                    node-&gt;right = right[k];</span><br><span class="line">                    v.<span class="built_in">push_back</span>(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Unique-BIT-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/Unique-BIT-II/" class="post-title-link" itemprop="url">LeetCode 95. Unique Binary Search Trees II</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 15:38:00 / 修改时间：15:50:39" itemprop="dateCreated datePublished" datetime="2021-11-15T15:38:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-95-Unique-Binary-Search-Trees-II"><a href="#LeetCode-95-Unique-Binary-Search-Trees-II" class="headerlink" title="LeetCode 95. Unique Binary Search Trees II"></a>LeetCode 95. Unique Binary Search Trees II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>n = 3</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>n = 1</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>[[1]]
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= n &lt;= 8</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个整数n，输出由n个结点组成的所有可能的二叉搜索树。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个循环，表示以第i个结点作为当前树的根结点，然后递归调用函数，使用比当前数字小的所有数字建立左子树，使用比当前数字大的所有数字作为右子树。由于左右子树中每个结点都可以作为子树的根结点，因此使用两个循环，每次取出一个结点作为根结点，再将这两个子树的根结点连接到根结点上，最后将这个根结点放入vector容器中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;  <span class="comment">//边界条件，直接返回</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;  <span class="comment">//遍历每个结点作为根结点的情况</span></span><br><span class="line">            vector&lt;TreeNode*&gt; vleft = <span class="built_in">CreateTree</span>(l,i<span class="number">-1</span>);  <span class="comment">//递归创建左子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; vright = <span class="built_in">CreateTree</span>(i+<span class="number">1</span>,r);  <span class="comment">//递归创建右子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vleft.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vright.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="comment">//以左子树的其中一个结点作为左子结点，以右子树中的其中一个结点作为右子结点</span></span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    root-&gt;left = vleft[j];</span><br><span class="line">                    root-&gt;right = vright[k];</span><br><span class="line">                    v.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CreateTree</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/decodestring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/decodestring/" class="post-title-link" itemprop="url">LeetCode 394. Decode String</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 14:56:00 / 修改时间：15:36:30" itemprop="dateCreated datePublished" datetime="2021-11-15T14:56:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">数据结构——栈</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-394-Decode-String"><a href="#LeetCode-394-Decode-String" class="headerlink" title="LeetCode 394. Decode String"></a>LeetCode 394. Decode String</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an encoded string, return its decoded string.   </p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>s = “3[a]2[bc]”</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>“aaabcbc”</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>s = “3[a2[c]]”</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>“accaccacc”</p>
<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>s = “2[abc]3[cd]ef”</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>“abcabccdcdcdef”</p>
<h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h2><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>s = “abc3[cd]xyz”</p>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>“abccdcdcdxyz”
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= s.length &lt;= 30<br>s consists of lowercase English letters, digits, and square brackets ‘[]’.<br>s is guaranteed to be a valid input.<br>All the integers in s are in the range [1, 300].</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个字符串，其中每个部分都是k[.]组成，k为正整数，方括号内部为一个字符串，表示k个字符串拼接在一起，如果k为1则省略k和括号。输出解码后的字符串。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于和括号匹配有关，考虑使用栈来实现。每次遇到前括号，就将读到的数字和字符串分别存入两个栈中，读到后括号时，把栈顶元素弹出，拼接上当前读取的字符串的整数倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; numstk;</span><br><span class="line">        stack&lt;string&gt; strstk;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;  <span class="comment">//数字</span></span><br><span class="line">                num = num*<span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i]))&#123;  <span class="comment">//字母</span></span><br><span class="line">                ans += s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>)&#123;  </span><br><span class="line">                numstk.<span class="built_in">push</span>(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                strstk.<span class="built_in">push</span>(ans);</span><br><span class="line">                ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//读到&#x27;]&#x27;</span></span><br><span class="line">                <span class="keyword">int</span> cnt = numstk.<span class="built_in">top</span>();  <span class="comment">//取出栈顶数字，是当前字符串的倍数</span></span><br><span class="line">                numstk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">                    strstk.<span class="built_in">top</span>() += ans;  <span class="comment">//在左括号之前的字符串之后添加当前字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                ans = strstk.<span class="built_in">top</span>();</span><br><span class="line">                strstk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Binary-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/Binary-Tree/" class="post-title-link" itemprop="url">homework - Binary Tree</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:40:00 / 修改时间：13:35:05" itemprop="dateCreated datePublished" datetime="2021-11-15T13:40:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Your task is very simple: Given a binary tree, every node of which contains one upper case character (‘A’ to ‘Z’); you just need to print all characters of this tree in pre-order.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input may contain several test data sets.<br>For each test data set, first comes one integer n (1 &lt;= n &lt;= 1000) in one line representing the number of nodes in the tree. Then n lines follow, each of them contains information of one tree node. One line consist of four members in order: i (integer, represents the identifier of this node, 1 &lt;= i &lt;= 1000, unique in this test data set), c (char, represents the content of this node described as above, ‘A’ &lt;= c &lt;= ‘Z’), l (integer, represents the identifier of the left child of this node, 0 &lt;= l &lt;= 1000, note that when l is 0 it means that there is no left child of this node), r (integer, represents the identifier of the right child of this node, 0 &lt;= r &lt;= 1000, note that when r is 0 it means that there is no right child of this node). These four members are separated by one space.<br>Input is ended by EOF(while(cin&gt;&gt;xxx)).<br>You can assume that all inputs are valid. All nodes can form only one valid binary tree in every test data set.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For every test data set, please traverse the given tree and print the content of each node in pre-order. Characters should be printed in one line without any separating space.</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>3<br>4 C 1 3<br>1 A 0 0<br>3 B 0 0<br>1<br>1000 Z 0 0<br>3<br>1 Q 0 2<br>2 W 3 0<br>3 Q 0 0  </p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>CAB<br>Z<br>QWQ</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于每一个案例，输入一棵树的结点数n，然后n行分别输入每个结点的id号，数据，左子结点的id和右子结点的id。输出这棵树的先序遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraversalTree</span><span class="params">(vector&lt;TreeNode&gt; v,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &lt;= <span class="number">0</span> || root &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v[root].data;</span><br><span class="line">    <span class="built_in">TraversalTree</span>(v,v[root].left);</span><br><span class="line">    <span class="built_in">TraversalTree</span>(v,v[root].right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="function">vector&lt;TreeNode&gt; <span class="title">v</span><span class="params">(<span class="number">1001</span>)</span></span>;  </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">1001</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//用于查找根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id,l,r;</span><br><span class="line">            <span class="keyword">char</span> dt;</span><br><span class="line">            cin &gt;&gt; id &gt;&gt; dt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            v[id].data = dt;</span><br><span class="line">            v[id].left = l;</span><br><span class="line">            v[id].right = r;</span><br><span class="line">            flag[id]++;</span><br><span class="line">            flag[l]++;</span><br><span class="line">            flag[r]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1001</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i] == <span class="number">0</span>)&#123;   <span class="comment">//找到根结点</span></span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="built_in">TraversalTree</span>(v,root);  <span class="comment">//先序遍历</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bjy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">bjy</p>
  <div class="site-description" itemprop="description">书山有路勤为径，学海无涯苦作舟</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/C0nF1D3nt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;C0nF1D3nt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      题库网站链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/" title="https:&#x2F;&#x2F;leetcode-cn.com" rel="noopener" target="_blank">LeetCode</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://codeforces.com/" title="http:&#x2F;&#x2F;codeforces.com" rel="noopener" target="_blank">Codeforces</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.luogu.com.cn/" title="https:&#x2F;&#x2F;www.luogu.com.cn" rel="noopener" target="_blank">洛谷</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://matrix.sysu.edu.cn/" title="https:&#x2F;&#x2F;matrix.sysu.edu.cn" rel="noopener" target="_blank">Matrix</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://pintia.cn/problem-sets?tab=0" title="https:&#x2F;&#x2F;pintia.cn&#x2F;problem-sets?tab&#x3D;0" rel="noopener" target="_blank">PTA</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bjy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">49k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">44 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
