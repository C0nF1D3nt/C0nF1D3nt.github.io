<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="书山有路勤为径，学海无涯苦作舟">
<meta property="og:type" content="website">
<meta property="og:title" content="Code King&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Code King&#39;s Blog">
<meta property="og:description" content="书山有路勤为径，学海无涯苦作舟">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bjy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Code King's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Code King's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="post-title-link" itemprop="url">最小生成树算法</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-10 15:44:00 / 修改时间：16:25:42" itemprop="dateCreated datePublished" datetime="2021-12-10T15:44:00+08:00">2021-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构——图</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h1><p>一个连通图的生成树是一个极小的连通子图，通过图中的$n-1$条边将图中的$n$个结点连接成一棵树。最小生成树是对有权图而言的。当这些边的权值之和最小时，得到的生成树就是最小生成树。</p>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim算法是一个典型的贪心算法。从某一个顶点开始循环，每次将生成树外距离生成树最近的一个顶点收入生成树中，并且更新这个顶点的邻接点距离当前生成树的距离，直到所有顶点都被收入生成树中后停止循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrimForMST</span><span class="params">(Graph g)</span></span>&#123;  <span class="comment">//传入一个图，包含图的顶点数、边数和邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> n = g.numVex;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mincost</span><span class="params">(n)</span></span>;  <span class="comment">//当前的生成树到每个顶点的最小距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">adjvex</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//当前生成树到每个顶点最小距离的顶点下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        mincost[i] = g.adj[<span class="number">0</span>][i];  <span class="comment">//当前生成树只有一个结点v0，因此距离为第一行的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;  <span class="comment">//找到当前距离生成树最小的一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(mincost[j] &amp;&amp; mincost[j] &lt; min)&#123;</span><br><span class="line">                min = mincost[j];</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,adjvex[idx],idx);  <span class="comment">//打印收入结点的路径</span></span><br><span class="line">        mincost[idx] = <span class="number">0</span>;  <span class="comment">//将这个结点收入生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i &lt; n; j++)&#123;  <span class="comment">//更新结点的最小距离</span></span><br><span class="line">            <span class="keyword">if</span>(mincost[j] &amp;&amp; gph.adj[idx][j] &lt; mincost[j])&#123; </span><br><span class="line">                <span class="comment">//当前结点未在生成树中，并且当前收入的结点到这个结点的距离小于之前的距离</span></span><br><span class="line">                mincost[j] = gph.adj[idx][j];  <span class="comment">//更新这个结点的最小距离</span></span><br><span class="line">                adjvex[j] = idx;  <span class="comment">//更新树中到这个结点最小距离的结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>Kruskal算法也是一个典型的贪心算法。我们将图中所有边的权重进行从小到大的排序，每次判断两侧的结点是否已在同一集合中，如果不在，就访问这条边的两个结点，将结点收入生成树中，继续循环，直到所有的结点都被收入生成树中。在算法中，使用边集数组来存储图结构，使用最小堆来取出权值最小的边，使用并查集判断结点是否在同一个集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id1;</span><br><span class="line">    <span class="keyword">int</span> id2;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(vector&lt;Edge&gt;&amp;edge,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//调整最小堆</span></span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span>*start;</span><br><span class="line">    edge[<span class="number">0</span>] = edge[start];</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= end)&#123;  <span class="comment">//每次循环将当前不正确的结点与两个子结点中较小的进行比较，如果小于子结点，则保持不动，退出循环；否则交换位置，继续向下层判断，直到放到正确的位置</span></span><br><span class="line">        <span class="keyword">if</span>(child &lt; end &amp;&amp; edge[child+<span class="number">1</span>].weight &lt; edge[child].weight)&#123; </span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edge[<span class="number">0</span>].weight &lt;= edge[child].weight)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edge[start] = edge[end];</span><br><span class="line">        start = end;</span><br><span class="line">        child *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    edge[start] = edge[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;Edge&gt;&amp; edge,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i++)&#123;  <span class="comment">//n/2是第一个存在子结点的中间结点，索引0为哨兵，下标从1开始</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(edge,i,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fa,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;  <span class="comment">//小于0表示当前结点为根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">Find</span>(fa,fa[x]);  <span class="comment">//否则进行递归，找到当前结点的根结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fa,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fa数组初始化为-1，负的数值表示当前集合的规模，如果为正表示当前结点的父结点的下标</span></span><br><span class="line">    <span class="keyword">if</span>(fa[x] &lt; fa[y])&#123;  <span class="comment">//将较小的并入较大的</span></span><br><span class="line">        fa[x] += fa[y];</span><br><span class="line">        fa[y] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fa[y] += fa[x];</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KruskalForMST</span><span class="params">(Graph g)</span></span>&#123;  <span class="comment">//图由边集数组存储，包含两侧的结点下标以及边的权重</span></span><br><span class="line">    <span class="keyword">int</span> n = g.numvex;</span><br><span class="line">    <span class="keyword">int</span> m = g.numedge;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">fa</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v = g.edge;</span><br><span class="line">    <span class="built_in">BuildHeap</span>(v,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(v[<span class="number">1</span>],v.<span class="built_in">back</span>());</span><br><span class="line">        Edge e = v.<span class="built_in">back</span>();</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">AdjustHeap</span>(v,<span class="number">1</span>,m-i);</span><br><span class="line">        <span class="keyword">int</span> root1 = <span class="built_in">Find</span>(fa,e.id1);</span><br><span class="line">        <span class="keyword">int</span> root2 = <span class="built_in">Find</span>(fa,e.id2);</span><br><span class="line">        <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">            <span class="built_in">Union</span>(fa,root1,root2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) %d\n&quot;</span>,e.id1,e.id2,e.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/09/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">Graph Traversal</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-09 22:02:00 / 修改时间：23:12:10" itemprop="dateCreated datePublished" datetime="2021-12-09T22:02:00+08:00">2021-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构——图</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图的遍历-Graph-Traversal"><a href="#图的遍历-Graph-Traversal" class="headerlink" title="图的遍历(Graph Traversal)"></a>图的遍历(Graph Traversal)</h1><p>图的遍历是从图中某一个结点处出发，对图中的每一个结点进行访问操作，并且每一个结点都只<strong>访问一次</strong>。</p>
<h2 id="1-图的深度优先遍历-DFS"><a href="#1-图的深度优先遍历-DFS" class="headerlink" title="1 图的深度优先遍历(DFS)"></a>1 图的深度优先遍历(DFS)</h2><h3 id="1-1-基于邻接矩阵的深度优先遍历"><a href="#1-1-基于邻接矩阵的深度优先遍历" class="headerlink" title="1.1 基于邻接矩阵的深度优先遍历"></a>1.1 基于邻接矩阵的深度优先遍历</h3><p>邻接矩阵中存储了图中各个结点直接的相邻关系。在无权图中，邻接矩阵中存储的值表示这两个顶点之间是否存在无向边，有边时值为1，无边时值为0；在有权图中，邻接矩阵中的值表示两个顶点之间无向边的权值，一般将其余值赋为正无穷。我们很容易看出对于无向图而言，邻接矩阵是一个对称矩阵，而在有向图中，邻接矩阵则不是对称矩阵。在深度优先遍历时，我们只需要在访问一个结点的同时，对它所有的邻接点进行递归遍历即可。</p>
<h4 id="无权图版本"><a href="#无权图版本" class="headerlink" title="无权图版本"></a>无权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adj,<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i] &amp;&amp; adj[idx][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">adj</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>)); <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        adj[x][y] = <span class="number">1</span>;</span><br><span class="line">        adj[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有权图版本"><a href="#有权图版本" class="headerlink" title="有权图版本"></a>有权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adj,<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i] &amp;&amp; adj[idx][i] != INF)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">adj</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,INF)); <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边及其权值</span></span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        adj[x][y] = w;</span><br><span class="line">        adj[y][x] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-基于邻接矩阵的深度优先遍历"><a href="#1-2-基于邻接矩阵的深度优先遍历" class="headerlink" title="1.2 基于邻接矩阵的深度优先遍历"></a>1.2 基于邻接矩阵的深度优先遍历</h3><p>邻接表对于每一个顶点都存储了每个顶点的邻接点，在遍历时，我们只需要在访问这个结点的同时递归访问它的邻接点即可。</p>
<h4 id="无权图版本-1"><a href="#无权图版本-1" class="headerlink" title="无权图版本"></a>无权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; adj[],<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[idx].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[adj[idx][i]])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,adj[idx][i],visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; adj[n]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        adj[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        adj[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有权图版本-1"><a href="#有权图版本-1" class="headerlink" title="有权图版本"></a>有权图版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> vexid;</span><br><span class="line">    Edge* next;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> id,<span class="keyword">int</span> w)&#123;</span><br><span class="line">        vexid = id;</span><br><span class="line">        weight = w;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    Edge* firstedge = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; adj[],<span class="keyword">int</span> idx,vector&lt;<span class="keyword">int</span>&gt;&amp; visited,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    visited[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Visit</span>(idx);  <span class="comment">//访问当前结点</span></span><br><span class="line">    Edge* p;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;vexid])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,p-&gt;vexid,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    <span class="function">vector&lt;Vertex&gt; <span class="title">adj</span><span class="params">(n)</span></span>; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        Edge* edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(y,w);</span><br><span class="line">        edge-&gt;next = adj[x]-&gt;firstedge;</span><br><span class="line">        adj[x]-&gt;firstedge = edge;</span><br><span class="line">        edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(x,w);</span><br><span class="line">        edge-&gt;next = adj[y]-&gt;firstedge;</span><br><span class="line">        adj[y]-&gt;firstedge = edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(adj,i,visited,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-图的广度优先遍历-BFS"><a href="#2-图的广度优先遍历-BFS" class="headerlink" title="2 图的广度优先遍历(BFS)"></a>2 图的广度优先遍历(BFS)</h2><p>使用一个队列，每访问一个一个结点就将它未访问的邻接点推入队列中即可。需要注意的是，在邻接点推入队列时就需要对这个点进行访问，而不能在出队列时才进行访问，否则会出现这个结点在队列中多次出现的情况导致结果的错误。</p>
<h3 id="2-1-基于邻接矩阵的广度优先遍历"><a href="#2-1-基于邻接矩阵的广度优先遍历" class="headerlink" title="2.1 基于邻接矩阵的广度优先遍历"></a>2.1 基于邻接矩阵的广度优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">adj</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>)); <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        adj[x][y] = <span class="number">1</span>;</span><br><span class="line">        adj[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Visit</span>(i);</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[j] &amp;&amp; adj[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(j);</span><br><span class="line">                        visited[j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">Visit</span>(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-基于邻接表的广度优先遍历"><a href="#2-2-基于邻接表的广度优先遍历" class="headerlink" title="2.2 基于邻接表的广度优先遍历"></a>2.2 基于邻接表的广度优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vexid;</span><br><span class="line">    Edge* next;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> id)&#123;</span><br><span class="line">        vexid = id;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    Edge* firstedge = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//输入点的个数和边的个数</span></span><br><span class="line">    <span class="function">vector&lt;Vertex&gt; <span class="title">adj</span><span class="params">(n)</span></span>; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;  <span class="comment">//输入每一条边</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        Edge* edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(y);</span><br><span class="line">        edge-&gt;next = adj[x]-&gt;firstedge;</span><br><span class="line">        adj[x]-&gt;firstedge = edge;</span><br><span class="line">        edge = <span class="keyword">new</span> <span class="built_in">Edge</span>(x);</span><br><span class="line">        edge-&gt;next = adj[y]-&gt;firstedge;</span><br><span class="line">        adj[y]-&gt;firstedge = edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;  <span class="comment">//访问标记</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Visit</span>(i);</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                Edge* p = adj[x]-&gt;firstedge;</span><br><span class="line">                <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[p-&gt;vexid])&#123;</span><br><span class="line">                        visited[p-&gt;vexid] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">Visit</span>(p-&gt;vexid);</span><br><span class="line">                        q.<span class="built_in">push</span>(p-&gt;vexid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/All-possible-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/All-possible-tree/" class="post-title-link" itemprop="url">LeetCode 894. All Possible Full Binary Trees</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 15:57:00 / 修改时间：15:56:12" itemprop="dateCreated datePublished" datetime="2021-11-15T15:57:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-894-All-Possible-Full-Binary-Trees"><a href="#LeetCode-894-All-Possible-Full-Binary-Trees" class="headerlink" title="LeetCode 894. All Possible Full Binary Trees"></a>LeetCode 894. All Possible Full Binary Trees</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.      </p>
<p>Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.      </p>
<p>A full binary tree is a binary tree where each node has exactly 0 or 2 children.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>n = 7</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>n = 3</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>[[0,0,0]]
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= n &lt;= 20</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个整数n，输出由n个结点组成的所有可能的二叉树，这个二叉树必须满足每个结点都有0个或者2个子结点，每个结点的值都为0。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于每个结点都有0个或者2个子结点，故n一定为奇数，所以按照从小到大的顺序进行遍历，设左侧结点数为i，递归调用函数建立子树，右侧同理，然后接到当前的根结点上即可建立一棵符合条件的二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;  <span class="comment">//边界条件，如果只有一个结点，就创建然后返回</span></span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">            v.<span class="built_in">push_back</span>(node);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i += <span class="number">2</span>)&#123;  <span class="comment">//遍历所有可能情况，左侧结点为i个，右侧结点为n-i-1个</span></span><br><span class="line">            vector&lt;TreeNode*&gt; left = <span class="built_in">allPossibleFBT</span>(i);  <span class="comment">//递归建立左子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; right = <span class="built_in">allPossibleFBT</span>(n-i<span class="number">-1</span>);  <span class="comment">//递归建立右子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; left.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; right.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="comment">//从左右子树取出任意一个作为根结点，然后接在当前这个根结点上</span></span><br><span class="line">                    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                    node-&gt;left = left[j];</span><br><span class="line">                    node-&gt;right = right[k];</span><br><span class="line">                    v.<span class="built_in">push_back</span>(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Unique-BIT-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/Unique-BIT-II/" class="post-title-link" itemprop="url">LeetCode 95. Unique Binary Search Trees II</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 15:38:00 / 修改时间：15:50:39" itemprop="dateCreated datePublished" datetime="2021-11-15T15:38:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-95-Unique-Binary-Search-Trees-II"><a href="#LeetCode-95-Unique-Binary-Search-Trees-II" class="headerlink" title="LeetCode 95. Unique Binary Search Trees II"></a>LeetCode 95. Unique Binary Search Trees II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>n = 3</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>n = 1</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>[[1]]
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= n &lt;= 8</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个整数n，输出由n个结点组成的所有可能的二叉搜索树。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个循环，表示以第i个结点作为当前树的根结点，然后递归调用函数，使用比当前数字小的所有数字建立左子树，使用比当前数字大的所有数字作为右子树。由于左右子树中每个结点都可以作为子树的根结点，因此使用两个循环，每次取出一个结点作为根结点，再将这两个子树的根结点连接到根结点上，最后将这个根结点放入vector容器中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;  <span class="comment">//边界条件，直接返回</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;  <span class="comment">//遍历每个结点作为根结点的情况</span></span><br><span class="line">            vector&lt;TreeNode*&gt; vleft = <span class="built_in">CreateTree</span>(l,i<span class="number">-1</span>);  <span class="comment">//递归创建左子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; vright = <span class="built_in">CreateTree</span>(i+<span class="number">1</span>,r);  <span class="comment">//递归创建右子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vleft.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vright.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="comment">//以左子树的其中一个结点作为左子结点，以右子树中的其中一个结点作为右子结点</span></span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    root-&gt;left = vleft[j];</span><br><span class="line">                    root-&gt;right = vright[k];</span><br><span class="line">                    v.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CreateTree</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/decodestring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/decodestring/" class="post-title-link" itemprop="url">LeetCode 394. Decode String</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 14:56:00 / 修改时间：15:36:30" itemprop="dateCreated datePublished" datetime="2021-11-15T14:56:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">数据结构——栈</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-394-Decode-String"><a href="#LeetCode-394-Decode-String" class="headerlink" title="LeetCode 394. Decode String"></a>LeetCode 394. Decode String</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an encoded string, return its decoded string.   </p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>s = “3[a]2[bc]”</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>“aaabcbc”</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>s = “3[a2[c]]”</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>“accaccacc”</p>
<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>s = “2[abc]3[cd]ef”</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>“abcabccdcdcdef”</p>
<h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h2><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>s = “abc3[cd]xyz”</p>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>“abccdcdcdxyz”
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= s.length &lt;= 30<br>s consists of lowercase English letters, digits, and square brackets ‘[]’.<br>s is guaranteed to be a valid input.<br>All the integers in s are in the range [1, 300].</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个字符串，其中每个部分都是k[.]组成，k为正整数，方括号内部为一个字符串，表示k个字符串拼接在一起，如果k为1则省略k和括号。输出解码后的字符串。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于和括号匹配有关，考虑使用栈来实现。每次遇到前括号，就将读到的数字和字符串分别存入两个栈中，读到后括号时，把栈顶元素弹出，拼接上当前读取的字符串的整数倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; numstk;</span><br><span class="line">        stack&lt;string&gt; strstk;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;  <span class="comment">//数字</span></span><br><span class="line">                num = num*<span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i]))&#123;  <span class="comment">//字母</span></span><br><span class="line">                ans += s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>)&#123;  </span><br><span class="line">                numstk.<span class="built_in">push</span>(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                strstk.<span class="built_in">push</span>(ans);</span><br><span class="line">                ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//读到&#x27;]&#x27;</span></span><br><span class="line">                <span class="keyword">int</span> cnt = numstk.<span class="built_in">top</span>();  <span class="comment">//取出栈顶数字，是当前字符串的倍数</span></span><br><span class="line">                numstk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">                    strstk.<span class="built_in">top</span>() += ans;  <span class="comment">//在左括号之前的字符串之后添加当前字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                ans = strstk.<span class="built_in">top</span>();</span><br><span class="line">                strstk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Binary-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/Binary-Tree/" class="post-title-link" itemprop="url">homework - Binary Tree</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:40:00 / 修改时间：13:35:05" itemprop="dateCreated datePublished" datetime="2021-11-15T13:40:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Your task is very simple: Given a binary tree, every node of which contains one upper case character (‘A’ to ‘Z’); you just need to print all characters of this tree in pre-order.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input may contain several test data sets.<br>For each test data set, first comes one integer n (1 &lt;= n &lt;= 1000) in one line representing the number of nodes in the tree. Then n lines follow, each of them contains information of one tree node. One line consist of four members in order: i (integer, represents the identifier of this node, 1 &lt;= i &lt;= 1000, unique in this test data set), c (char, represents the content of this node described as above, ‘A’ &lt;= c &lt;= ‘Z’), l (integer, represents the identifier of the left child of this node, 0 &lt;= l &lt;= 1000, note that when l is 0 it means that there is no left child of this node), r (integer, represents the identifier of the right child of this node, 0 &lt;= r &lt;= 1000, note that when r is 0 it means that there is no right child of this node). These four members are separated by one space.<br>Input is ended by EOF(while(cin&gt;&gt;xxx)).<br>You can assume that all inputs are valid. All nodes can form only one valid binary tree in every test data set.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For every test data set, please traverse the given tree and print the content of each node in pre-order. Characters should be printed in one line without any separating space.</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>3<br>4 C 1 3<br>1 A 0 0<br>3 B 0 0<br>1<br>1000 Z 0 0<br>3<br>1 Q 0 2<br>2 W 3 0<br>3 Q 0 0  </p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>CAB<br>Z<br>QWQ</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于每一个案例，输入一棵树的结点数n，然后n行分别输入每个结点的id号，数据，左子结点的id和右子结点的id。输出这棵树的先序遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraversalTree</span><span class="params">(vector&lt;TreeNode&gt; v,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &lt;= <span class="number">0</span> || root &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v[root].data;</span><br><span class="line">    <span class="built_in">TraversalTree</span>(v,v[root].left);</span><br><span class="line">    <span class="built_in">TraversalTree</span>(v,v[root].right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="function">vector&lt;TreeNode&gt; <span class="title">v</span><span class="params">(<span class="number">1001</span>)</span></span>;  </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">1001</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//用于查找根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id,l,r;</span><br><span class="line">            <span class="keyword">char</span> dt;</span><br><span class="line">            cin &gt;&gt; id &gt;&gt; dt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            v[id].data = dt;</span><br><span class="line">            v[id].left = l;</span><br><span class="line">            v[id].right = r;</span><br><span class="line">            flag[id]++;</span><br><span class="line">            flag[l]++;</span><br><span class="line">            flag[r]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1001</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i] == <span class="number">0</span>)&#123;   <span class="comment">//找到根结点</span></span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="built_in">TraversalTree</span>(v,root);  <span class="comment">//先序遍历</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/%E5%B7%B2%E7%9F%A5%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%B1%82%E5%8F%AF%E8%83%BD%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/%E5%B7%B2%E7%9F%A5%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%B1%82%E5%8F%AF%E8%83%BD%E6%80%A7/" class="post-title-link" itemprop="url">homework - 求不同形态二叉树</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:24:00 / 修改时间：13:25:17" itemprop="dateCreated datePublished" datetime="2021-11-15T13:24:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>994</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="求不同形态二叉树"><a href="#求不同形态二叉树" class="headerlink" title="求不同形态二叉树"></a>求不同形态二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定前序遍历和后序遍历的顺序，要求出总共有多少棵不同形态的二叉树满足这样的遍历顺序。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>整个输入有两行，第一行给出前序遍历的访问顺序，第二行给出后序遍历的访问顺序。<br>二叉树的结点用一个大写字母表示，不会有两个结点标上相同字母。输入数据不包含空格，且保证至少有一棵二叉树符合要求。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出一个整数，为符合要求的不同形态二叉树的数目。</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>ABCD<br>CBDA</p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>2</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们首先要知道为什么前序遍历和后序遍历不能唯一确定一棵二叉树。我们先考虑简单情况，当只有一个根结点时，显然是可以唯一确定一棵二叉树的；当有三个结点，且根结点存在左右子节点时，前序遍历和后序遍历也是可以唯一确定一棵二叉树的；当有两个结点时，问题发生了，由于其中一个结点为根结点，而另一个结点则为根结点的子结点。在先序遍历中，先访问根结点，再访问子结点；在后序遍历中，先访问子结点，再访问根结点。因此，我们并不能确定这个子结点是根结点的左子结点还是右子结点。这样的分析启示我们，我们只需要找到这棵树中有多少个这样的子树，也就是只有一个子结点的结点，每有一个这样的结点，就都有两种可能性，因此假设有n个这样的结点，那么二叉树的种数就是$2^n$种可能。怎么才能找到这样的结点呢？我们知道，前序遍历的根结点之后紧跟的是左子树，而后序遍历根结点之前的是右子树，如果这两个是相同的，那不就说明只存在一个子结点吗？因此我们可以遍历前序遍历的序列，对非根结点进行分析，我们在后序遍历中找到这个结点，如果前序遍历的后一个位置与后序遍历中这个结点的前一个位置元素相同，那么可能性就要乘以2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = s2.<span class="built_in">find</span>(s1[i]);</span><br><span class="line">        <span class="keyword">if</span>(s1[i+<span class="number">1</span>] == s2[idx<span class="number">-1</span>])&#123;</span><br><span class="line">            cnt *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/KMP/" class="post-title-link" itemprop="url">KMP算法</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-14 10:57:00 / 修改时间：14:31:23" itemprop="dateCreated datePublished" datetime="2021-11-14T10:57:00+08:00">2021-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%B8%B2/" itemprop="url" rel="index"><span itemprop="name">数据结构——串</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KMP算法是一种字符串匹配算法，是用来查找字符串中的子串的算法。给定文本串和模式串，查找模式串在匹配串中出现的位置，如果找不到则返回-1。</p>
<h2 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h2><p>在KMP算法中，构造一个next数组，当当前位置不匹配时，就将模式串的当前匹配位置j向前回溯到next[j]的位置，而不是回溯到最开始的地方重新开始匹配。这是因为如果在当前位置之前的已经匹配的部分(<strong>不考虑当前位置</strong>)中有一部分后缀和模式串的前缀是相同的，那么这个部分就一定是匹配的，而不需要重新进行匹配判断，这样就可以大大提高匹配的效率。</p>
<h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>那么如何才能求出next数组呢？这是KMP算法中最难理解的地方。我们将next[0]规定为-1，故当索引为-1的时候，就说明找不到匹配的前后缀，此时就只能重新开始匹配。我们遍历整个模式串数组，求得next数组的值。最开始的时候k是-1，j是0，于是我们让k和j都加1，由于下标为1的位置不存在匹配的前后缀，next数组的值自然为0。之后的每个位置中，k代表当前已经匹配的个数，如果当前位置仍然匹配，那么下一个位置的next数组的值一定是当前已经匹配的个数k再加上1；如果当前位置是不匹配的，那么此时就不存在k+1个匹配字符，我们必须将k向前回溯，让k等于next[k]。为什么是next[k]呢？这是因为next数组的含义是当前位置不匹配时下一个判断匹配的位置。因此让k等于next[k]之后，前面的位置一定是已经匹配的，只需要再进行当前位置的判断即可，如果k变为next[k]之后当前位置匹配了，那么就跟上面相同，下一个位置的next数组值就是当前匹配的个数next[k]+1，否则就继续回溯，直到k变为-1。如果k已经为-1了，那么说明找不到可以匹配的前后缀了，下个位置的next值自然是0。</p>
<h2 id="GetNext函数的改进"><a href="#GetNext函数的改进" class="headerlink" title="GetNext函数的改进"></a>GetNext函数的改进</h2><p>存在一种情况，就是回溯之后位置的字符和回溯前字符是相同的，那么在当前位置出现不匹配时，即使回溯，我们无需判断就知道一定是不匹配的，这种情况下就出现了多余的判断。因此我们对算法进行改进，如果回溯后的位置和当前位置的元素相同，那么就再向前回溯一次，也就是next[j] = next[k]。</p>
<h2 id="字符串的匹配"><a href="#字符串的匹配" class="headerlink" title="字符串的匹配"></a>字符串的匹配</h2><p>在匹配的过程中，我们下标从i = 0，j = 0开始。如果当前位置匹配，就将i和j都加1；如果不匹配，就使用我们刚才得到的next数组向前回溯，继续判断下一个位置是否匹配。如果j到达-1，说明找不到匹配的前后缀了，说明这个位置无论如何都无法匹配，那么就只能让i和j都往后以一个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(string p,vector&lt;<span class="keyword">int</span>&gt;&amp; next)</span></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;  </span><br><span class="line">            <span class="comment">//k为-1表示找不到匹配的前后缀，所以next[j]为0</span></span><br><span class="line">            <span class="comment">//p[j] == p[k]表示当前位置相等，k表示当前已经匹配的个数</span></span><br><span class="line">            <span class="comment">//故下一个位置j+1的next值为k+1</span></span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span>(p[j] != p[k])&#123;  </span><br><span class="line">                <span class="comment">//如果当前两个位置相同，那么回溯之后一定不匹配，于是再往前回溯</span></span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="comment">//当前位置匹配失败，往前回溯再次匹配</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(string str,string p,vector&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || str[i] == p[j])&#123;</span><br><span class="line">            <span class="comment">//j为-1表示回溯之后一直不匹配</span></span><br><span class="line">            <span class="comment">//或者当前位置匹配，此时向后移动一个位置</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前位置不匹配，向前回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == n)&#123;  <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string str,p;  <span class="comment">//文本串和模式串</span></span><br><span class="line">    cin &gt;&gt; str &gt;&gt; p; </span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>; </span><br><span class="line">    <span class="built_in">GetNext</span>(p,next);  <span class="comment">//求next数组</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">KMP</span>(str,p,next);  <span class="comment">//查找模式串p在文本串str中的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">中缀表达式转后缀表达式(PTA 数据结构(中文) 7-20)</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-14 10:57:00 / 修改时间：16:59:11" itemprop="dateCreated datePublished" datetime="2021-11-14T10:57:00+08:00">2021-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">数据结构——栈</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入在一行中给出不含空格的中缀表达式，可包含+、-、*、\以及左右括号()，表达式不超过20个字符。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>2+3*(7-4)+8/4</p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>2 3 7 4 - * + 8 4 / +</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先读取整个中缀表达式，遍历整个表达式，当遇到操作数时，将操作数放入后缀表达式的字符串中；当遇到操作符时，如果栈为空，则入栈；如果栈不为空，就比较当前操作符和栈顶操作符的优先级，如果当前操作符优先级高，就压入栈中，如果相等，则将栈顶元素出栈(默认只有左右括号为相等)，如果当前操作符的优先级低，则将栈顶元素出栈，并且放入后缀表达式中，重复这个操作，直到这个运算符压入栈中，或者与左括号匹配时停止循环。重复读取判断直到整个表达式读取完毕，最后将栈中元素全都放入后缀表达式字符串中即可。<br>注意点：当操作数不为整数，或者操作数前存在正负号时，需要特殊处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;, <span class="keyword">char</span>&gt; mp =   <span class="comment">//优先级表</span></span><br><span class="line">&#123;	</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;=&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;-&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string inorder,postorder;</span><br><span class="line">    cin &gt;&gt; inorder;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(inorder[i]) || inorder[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || inorder[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>) || inorder[i] == <span class="string">&#x27;+&#x27;</span> </span><br><span class="line">        &amp;&amp; (i == <span class="number">0</span> || inorder[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>))&#123;  <span class="comment">//如果是数字，或者是数字前面的正负号</span></span><br><span class="line">            <span class="keyword">if</span>(postorder != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                postorder += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] != <span class="string">&#x27;+&#x27;</span>)&#123;  <span class="comment">//数字前的＋不需要放入后缀表达式</span></span><br><span class="line">                postorder += inorder[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(inorder[i]) || inorder[i] == <span class="string">&#x27;.&#x27;</span>)&#123;  <span class="comment">//将整个操作数放入后缀表达式中</span></span><br><span class="line">                postorder += inorder[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//操作符的情况</span></span><br><span class="line">            <span class="keyword">if</span>(op.<span class="built_in">empty</span>())&#123;  <span class="comment">//栈为空则直接压入</span></span><br><span class="line">                op.<span class="built_in">push</span>(inorder[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//栈不空，需要进行优先级判断</span></span><br><span class="line">                <span class="keyword">char</span> comp = mp[&#123;op.<span class="built_in">top</span>(),inorder[i]&#125;];</span><br><span class="line">                <span class="keyword">if</span>(comp == <span class="string">&#x27;&lt;&#x27;</span>)&#123;  <span class="comment">//当前元素优先级高，则直接压入栈中</span></span><br><span class="line">                    op.<span class="built_in">push</span>(inorder[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(comp == <span class="string">&#x27;=&#x27;</span>)&#123;  <span class="comment">//当前元素优先级等于栈顶元素优先级(左右括号)，则直接将左括号出栈</span></span><br><span class="line">                    op.<span class="built_in">pop</span>();</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;   <span class="comment">//当前元素优先级低</span></span><br><span class="line">                    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>() &amp;&amp; mp[&#123;op.<span class="built_in">top</span>(),inorder[i]&#125;] == <span class="string">&#x27;&gt;&#x27;</span>)&#123;  </span><br><span class="line">                        <span class="comment">//当栈不空且当前元素优先级低于栈顶元素时，将栈顶元素出栈并且放入后缀表达式中</span></span><br><span class="line">                        <span class="keyword">if</span>(postorder != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                            postorder += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        postorder += op.<span class="built_in">top</span>();</span><br><span class="line">                        op.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>())&#123;  <span class="comment">//将栈中所有运算符放入后缀表达式中</span></span><br><span class="line">        <span class="keyword">if</span>(postorder != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            postorder += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder += op.<span class="built_in">top</span>();</span><br><span class="line">        op.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; postorder;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" class="post-title-link" itemprop="url">前缀表达式求值(PTA 数据结构(中文) 7-21)</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-14 10:57:00 / 修改时间：14:52:14" itemprop="dateCreated datePublished" datetime="2021-11-14T10:57:00+08:00">2021-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">数据结构——栈</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前缀表达式求值"><a href="#前缀表达式求值" class="headerlink" title="前缀表达式求值"></a>前缀表达式求值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>+ + 2 * 3 - 7 4 / 8 4</p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>13.0</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从后往前读取前缀表达式，将读到的元素存到一个临时的字符串中，读到空格或者字符串最前面时停止。处理当前读到的字符串时，如果是数字，就压入栈中；如果是运算符，就取出栈中的两个元素(不足两个元素则错误)，与该运算符进行运算，再将结果压入栈中。重复操作，直到整个表达式处理完毕。最后如果栈中只剩一个元素，则输出结果，否则表达式错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2,<span class="keyword">char</span> op)</span></span>&#123;  <span class="comment">//表达式求值</span></span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num2 == <span class="number">0</span>)&#123;  <span class="comment">//除数为0</span></span><br><span class="line">            <span class="keyword">return</span> DBL_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1 / num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DBL_MIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string preorder;</span><br><span class="line">    <span class="built_in">getline</span>(cin,preorder);</span><br><span class="line">    <span class="keyword">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="keyword">double</span>&gt; stk;</span><br><span class="line">    set&lt;<span class="keyword">char</span>&gt; opset = &#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = n<span class="number">-1</span>;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;  <span class="comment">//临时字符串，用来存当前元素</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;  <span class="comment">//判断是数字还是操作符，数字为1，操作符为0</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; preorder[i] != <span class="string">&#x27; &#x27;</span>)&#123;  <span class="comment">//读取一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                flag = <span class="built_in">isdigit</span>(preorder[i]) ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            s += preorder[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;  <span class="comment">//数字</span></span><br><span class="line">            <span class="keyword">double</span> num = <span class="built_in">stod</span>(s);</span><br><span class="line">            stk.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//操作符</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; opset.<span class="built_in">find</span>(s[<span class="number">0</span>]) != opset.<span class="built_in">end</span>())&#123;  <span class="comment">//正确的操作符</span></span><br><span class="line">                <span class="keyword">char</span> op = s[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">double</span> num1 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">double</span> num2 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">double</span> res = <span class="built_in">Calculate</span>(num1,num2,op);</span><br><span class="line">                <span class="keyword">if</span>(res == DBL_MIN)&#123;  <span class="comment">//结果出错</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(res);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; preorder[i] == <span class="string">&#x27; &#x27;</span>)&#123;  <span class="comment">//处理空格</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stk.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; stk.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bjy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">bjy</p>
  <div class="site-description" itemprop="description">书山有路勤为径，学海无涯苦作舟</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/C0nF1D3nt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;C0nF1D3nt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      题库网站链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/" title="https:&#x2F;&#x2F;leetcode-cn.com" rel="noopener" target="_blank">LeetCode</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://codeforces.com/" title="http:&#x2F;&#x2F;codeforces.com" rel="noopener" target="_blank">Codeforces</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.luogu.com.cn/" title="https:&#x2F;&#x2F;www.luogu.com.cn" rel="noopener" target="_blank">洛谷</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://matrix.sysu.edu.cn/" title="https:&#x2F;&#x2F;matrix.sysu.edu.cn" rel="noopener" target="_blank">Matrix</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://pintia.cn/problem-sets?tab=0" title="https:&#x2F;&#x2F;pintia.cn&#x2F;problem-sets?tab&#x3D;0" rel="noopener" target="_blank">PTA</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bjy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">45k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">40 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
