<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="书山有路勤为径，学海无涯苦作舟">
<meta property="og:type" content="website">
<meta property="og:title" content="Code King&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Code King&#39;s Blog">
<meta property="og:description" content="书山有路勤为径，学海无涯苦作舟">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bjy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Code King's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Code King's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/All-possible-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/All-possible-tree/" class="post-title-link" itemprop="url">LeetCode 894. All Possible Full Binary Trees</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 15:57:00 / 修改时间：15:56:12" itemprop="dateCreated datePublished" datetime="2021-11-15T15:57:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-894-All-Possible-Full-Binary-Trees"><a href="#LeetCode-894-All-Possible-Full-Binary-Trees" class="headerlink" title="LeetCode 894. All Possible Full Binary Trees"></a>LeetCode 894. All Possible Full Binary Trees</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.      </p>
<p>Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.      </p>
<p>A full binary tree is a binary tree where each node has exactly 0 or 2 children.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>n = 7</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>n = 3</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>[[0,0,0]]
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= n &lt;= 20</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个整数n，输出由n个结点组成的所有可能的二叉树，这个二叉树必须满足每个结点都有0个或者2个子结点，每个结点的值都为0。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于每个结点都有0个或者2个子结点，故n一定为奇数，所以按照从小到大的顺序进行遍历，设左侧结点数为i，递归调用函数建立子树，右侧同理，然后接到当前的根结点上即可建立一棵符合条件的二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;  <span class="comment">//边界条件，如果只有一个结点，就创建然后返回</span></span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">            v.<span class="built_in">push_back</span>(node);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i += <span class="number">2</span>)&#123;  <span class="comment">//遍历所有可能情况，左侧结点为i个，右侧结点为n-i-1个</span></span><br><span class="line">            vector&lt;TreeNode*&gt; left = <span class="built_in">allPossibleFBT</span>(i);  <span class="comment">//递归建立左子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; right = <span class="built_in">allPossibleFBT</span>(n-i<span class="number">-1</span>);  <span class="comment">//递归建立右子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; left.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; right.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="comment">//从左右子树取出任意一个作为根结点，然后接在当前这个根结点上</span></span><br><span class="line">                    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                    node-&gt;left = left[j];</span><br><span class="line">                    node-&gt;right = right[k];</span><br><span class="line">                    v.<span class="built_in">push_back</span>(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Unique-BIT-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/Unique-BIT-II/" class="post-title-link" itemprop="url">LeetCode 95. Unique Binary Search Trees II</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 15:38:00 / 修改时间：15:50:39" itemprop="dateCreated datePublished" datetime="2021-11-15T15:38:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-95-Unique-Binary-Search-Trees-II"><a href="#LeetCode-95-Unique-Binary-Search-Trees-II" class="headerlink" title="LeetCode 95. Unique Binary Search Trees II"></a>LeetCode 95. Unique Binary Search Trees II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>n = 3</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>n = 1</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>[[1]]
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= n &lt;= 8</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个整数n，输出由n个结点组成的所有可能的二叉搜索树。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个循环，表示以第i个结点作为当前树的根结点，然后递归调用函数，使用比当前数字小的所有数字建立左子树，使用比当前数字大的所有数字作为右子树。由于左右子树中每个结点都可以作为子树的根结点，因此使用两个循环，每次取出一个结点作为根结点，再将这两个子树的根结点连接到根结点上，最后将这个根结点放入vector容器中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;  <span class="comment">//边界条件，直接返回</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;  <span class="comment">//遍历每个结点作为根结点的情况</span></span><br><span class="line">            vector&lt;TreeNode*&gt; vleft = <span class="built_in">CreateTree</span>(l,i<span class="number">-1</span>);  <span class="comment">//递归创建左子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; vright = <span class="built_in">CreateTree</span>(i+<span class="number">1</span>,r);  <span class="comment">//递归创建右子树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vleft.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vright.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="comment">//以左子树的其中一个结点作为左子结点，以右子树中的其中一个结点作为右子结点</span></span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    root-&gt;left = vleft[j];</span><br><span class="line">                    root-&gt;right = vright[k];</span><br><span class="line">                    v.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CreateTree</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/decodestring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/decodestring/" class="post-title-link" itemprop="url">LeetCode 394. Decode String</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 14:56:00 / 修改时间：15:36:30" itemprop="dateCreated datePublished" datetime="2021-11-15T14:56:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">数据结构——栈</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-394-Decode-String"><a href="#LeetCode-394-Decode-String" class="headerlink" title="LeetCode 394. Decode String"></a>LeetCode 394. Decode String</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an encoded string, return its decoded string.   </p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>s = “3[a]2[bc]”</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>“aaabcbc”</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>s = “3[a2[c]]”</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>“accaccacc”</p>
<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>s = “2[abc]3[cd]ef”</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>“abcabccdcdcdef”</p>
<h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h2><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>s = “abc3[cd]xyz”</p>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>“abccdcdcdxyz”
 </p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>1 &lt;= s.length &lt;= 30<br>s consists of lowercase English letters, digits, and square brackets ‘[]’.<br>s is guaranteed to be a valid input.<br>All the integers in s are in the range [1, 300].</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个字符串，其中每个部分都是k[.]组成，k为正整数，方括号内部为一个字符串，表示k个字符串拼接在一起，如果k为1则省略k和括号。输出解码后的字符串。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于和括号匹配有关，考虑使用栈来实现。每次遇到前括号，就将读到的数字和字符串分别存入两个栈中，读到后括号时，把栈顶元素弹出，拼接上当前读取的字符串的整数倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; numstk;</span><br><span class="line">        stack&lt;string&gt; strstk;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;  <span class="comment">//数字</span></span><br><span class="line">                num = num*<span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i]))&#123;  <span class="comment">//字母</span></span><br><span class="line">                ans += s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>)&#123;  </span><br><span class="line">                numstk.<span class="built_in">push</span>(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                strstk.<span class="built_in">push</span>(ans);</span><br><span class="line">                ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//读到&#x27;]&#x27;</span></span><br><span class="line">                <span class="keyword">int</span> cnt = numstk.<span class="built_in">top</span>();  <span class="comment">//取出栈顶数字，是当前字符串的倍数</span></span><br><span class="line">                numstk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">                    strstk.<span class="built_in">top</span>() += ans;  <span class="comment">//在左括号之前的字符串之后添加当前字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                ans = strstk.<span class="built_in">top</span>();</span><br><span class="line">                strstk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Binary-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/Binary-Tree/" class="post-title-link" itemprop="url">homework - Binary Tree</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:40:00 / 修改时间：13:35:05" itemprop="dateCreated datePublished" datetime="2021-11-15T13:40:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Your task is very simple: Given a binary tree, every node of which contains one upper case character (‘A’ to ‘Z’); you just need to print all characters of this tree in pre-order.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input may contain several test data sets.<br>For each test data set, first comes one integer n (1 &lt;= n &lt;= 1000) in one line representing the number of nodes in the tree. Then n lines follow, each of them contains information of one tree node. One line consist of four members in order: i (integer, represents the identifier of this node, 1 &lt;= i &lt;= 1000, unique in this test data set), c (char, represents the content of this node described as above, ‘A’ &lt;= c &lt;= ‘Z’), l (integer, represents the identifier of the left child of this node, 0 &lt;= l &lt;= 1000, note that when l is 0 it means that there is no left child of this node), r (integer, represents the identifier of the right child of this node, 0 &lt;= r &lt;= 1000, note that when r is 0 it means that there is no right child of this node). These four members are separated by one space.<br>Input is ended by EOF(while(cin&gt;&gt;xxx)).<br>You can assume that all inputs are valid. All nodes can form only one valid binary tree in every test data set.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For every test data set, please traverse the given tree and print the content of each node in pre-order. Characters should be printed in one line without any separating space.</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>3<br>4 C 1 3<br>1 A 0 0<br>3 B 0 0<br>1<br>1000 Z 0 0<br>3<br>1 Q 0 2<br>2 W 3 0<br>3 Q 0 0  </p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>CAB<br>Z<br>QWQ</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于每一个案例，输入一棵树的结点数n，然后n行分别输入每个结点的id号，数据，左子结点的id和右子结点的id。输出这棵树的先序遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraversalTree</span><span class="params">(vector&lt;TreeNode&gt; v,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &lt;= <span class="number">0</span> || root &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v[root].data;</span><br><span class="line">    <span class="built_in">TraversalTree</span>(v,v[root].left);</span><br><span class="line">    <span class="built_in">TraversalTree</span>(v,v[root].right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="function">vector&lt;TreeNode&gt; <span class="title">v</span><span class="params">(<span class="number">1001</span>)</span></span>;  </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">1001</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//用于查找根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id,l,r;</span><br><span class="line">            <span class="keyword">char</span> dt;</span><br><span class="line">            cin &gt;&gt; id &gt;&gt; dt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            v[id].data = dt;</span><br><span class="line">            v[id].left = l;</span><br><span class="line">            v[id].right = r;</span><br><span class="line">            flag[id]++;</span><br><span class="line">            flag[l]++;</span><br><span class="line">            flag[r]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1001</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i] == <span class="number">0</span>)&#123;   <span class="comment">//找到根结点</span></span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="built_in">TraversalTree</span>(v,root);  <span class="comment">//先序遍历</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/%E5%B7%B2%E7%9F%A5%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%B1%82%E5%8F%AF%E8%83%BD%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/%E5%B7%B2%E7%9F%A5%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%B1%82%E5%8F%AF%E8%83%BD%E6%80%A7/" class="post-title-link" itemprop="url">homework - 求不同形态二叉树</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:24:00 / 修改时间：13:25:17" itemprop="dateCreated datePublished" datetime="2021-11-15T13:24:00+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>994</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="求不同形态二叉树"><a href="#求不同形态二叉树" class="headerlink" title="求不同形态二叉树"></a>求不同形态二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定前序遍历和后序遍历的顺序，要求出总共有多少棵不同形态的二叉树满足这样的遍历顺序。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>整个输入有两行，第一行给出前序遍历的访问顺序，第二行给出后序遍历的访问顺序。<br>二叉树的结点用一个大写字母表示，不会有两个结点标上相同字母。输入数据不包含空格，且保证至少有一棵二叉树符合要求。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出一个整数，为符合要求的不同形态二叉树的数目。</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>ABCD<br>CBDA</p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>2</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们首先要知道为什么前序遍历和后序遍历不能唯一确定一棵二叉树。我们先考虑简单情况，当只有一个根结点时，显然是可以唯一确定一棵二叉树的；当有三个结点，且根结点存在左右子节点时，前序遍历和后序遍历也是可以唯一确定一棵二叉树的；当有两个结点时，问题发生了，由于其中一个结点为根结点，而另一个结点则为根结点的子结点。在先序遍历中，先访问根结点，再访问子结点；在后序遍历中，先访问子结点，再访问根结点。因此，我们并不能确定这个子结点是根结点的左子结点还是右子结点。这样的分析启示我们，我们只需要找到这棵树中有多少个这样的子树，也就是只有一个子结点的结点，每有一个这样的结点，就都有两种可能性，因此假设有n个这样的结点，那么二叉树的种数就是$2^n$种可能。怎么才能找到这样的结点呢？我们知道，前序遍历的根结点之后紧跟的是左子树，而后序遍历根结点之前的是右子树，如果这两个是相同的，那不就说明只存在一个子结点吗？因此我们可以遍历前序遍历的序列，对非根结点进行分析，我们在后序遍历中找到这个结点，如果前序遍历的后一个位置与后序遍历中这个结点的前一个位置元素相同，那么可能性就要乘以2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = s2.<span class="built_in">find</span>(s1[i]);</span><br><span class="line">        <span class="keyword">if</span>(s1[i+<span class="number">1</span>] == s2[idx<span class="number">-1</span>])&#123;</span><br><span class="line">            cnt *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/KMP/" class="post-title-link" itemprop="url">KMP算法</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-14 10:57:00 / 修改时间：14:31:23" itemprop="dateCreated datePublished" datetime="2021-11-14T10:57:00+08:00">2021-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%B8%B2/" itemprop="url" rel="index"><span itemprop="name">数据结构——串</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KMP算法是一种字符串匹配算法，是用来查找字符串中的子串的算法。给定文本串和模式串，查找模式串在匹配串中出现的位置，如果找不到则返回-1。</p>
<h2 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h2><p>在KMP算法中，构造一个next数组，当当前位置不匹配时，就将模式串的当前匹配位置j向前回溯到next[j]的位置，而不是回溯到最开始的地方重新开始匹配。这是因为如果在当前位置之前的已经匹配的部分(<strong>不考虑当前位置</strong>)中有一部分后缀和模式串的前缀是相同的，那么这个部分就一定是匹配的，而不需要重新进行匹配判断，这样就可以大大提高匹配的效率。</p>
<h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>那么如何才能求出next数组呢？这是KMP算法中最难理解的地方。我们将next[0]规定为-1，故当索引为-1的时候，就说明找不到匹配的前后缀，此时就只能重新开始匹配。我们遍历整个模式串数组，求得next数组的值。最开始的时候k是-1，j是0，于是我们让k和j都加1，由于下标为1的位置不存在匹配的前后缀，next数组的值自然为0。之后的每个位置中，k代表当前已经匹配的个数，如果当前位置仍然匹配，那么下一个位置的next数组的值一定是当前已经匹配的个数k再加上1；如果当前位置是不匹配的，那么此时就不存在k+1个匹配字符，我们必须将k向前回溯，让k等于next[k]。为什么是next[k]呢？这是因为next数组的含义是当前位置不匹配时下一个判断匹配的位置。因此让k等于next[k]之后，前面的位置一定是已经匹配的，只需要再进行当前位置的判断即可，如果k变为next[k]之后当前位置匹配了，那么就跟上面相同，下一个位置的next数组值就是当前匹配的个数next[k]+1，否则就继续回溯，直到k变为-1。如果k已经为-1了，那么说明找不到可以匹配的前后缀了，下个位置的next值自然是0。</p>
<h2 id="GetNext函数的改进"><a href="#GetNext函数的改进" class="headerlink" title="GetNext函数的改进"></a>GetNext函数的改进</h2><p>存在一种情况，就是回溯之后位置的字符和回溯前字符是相同的，那么在当前位置出现不匹配时，即使回溯，我们无需判断就知道一定是不匹配的，这种情况下就出现了多余的判断。因此我们对算法进行改进，如果回溯后的位置和当前位置的元素相同，那么就再向前回溯一次，也就是next[j] = next[k]。</p>
<h2 id="字符串的匹配"><a href="#字符串的匹配" class="headerlink" title="字符串的匹配"></a>字符串的匹配</h2><p>在匹配的过程中，我们下标从i = 0，j = 0开始。如果当前位置匹配，就将i和j都加1；如果不匹配，就使用我们刚才得到的next数组向前回溯，继续判断下一个位置是否匹配。如果j到达-1，说明找不到匹配的前后缀了，说明这个位置无论如何都无法匹配，那么就只能让i和j都往后以一个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(string p,vector&lt;<span class="keyword">int</span>&gt;&amp; next)</span></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;  </span><br><span class="line">            <span class="comment">//k为-1表示找不到匹配的前后缀，所以next[j]为0</span></span><br><span class="line">            <span class="comment">//p[j] == p[k]表示当前位置相等，k表示当前已经匹配的个数</span></span><br><span class="line">            <span class="comment">//故下一个位置j+1的next值为k+1</span></span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span>(p[j] != p[k])&#123;  </span><br><span class="line">                <span class="comment">//如果当前两个位置相同，那么回溯之后一定不匹配，于是再往前回溯</span></span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="comment">//当前位置匹配失败，往前回溯再次匹配</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(string str,string p,vector&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || str[i] == p[j])&#123;</span><br><span class="line">            <span class="comment">//j为-1表示回溯之后一直不匹配</span></span><br><span class="line">            <span class="comment">//或者当前位置匹配，此时向后移动一个位置</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前位置不匹配，向前回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == n)&#123;  <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string str,p;  <span class="comment">//文本串和模式串</span></span><br><span class="line">    cin &gt;&gt; str &gt;&gt; p; </span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>; </span><br><span class="line">    <span class="built_in">GetNext</span>(p,next);  <span class="comment">//求next数组</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">KMP</span>(str,p,next);  <span class="comment">//查找模式串p在文本串str中的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">中缀表达式转后缀表达式(PTA 数据结构(中文) 7-20)</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-14 10:57:00 / 修改时间：16:59:11" itemprop="dateCreated datePublished" datetime="2021-11-14T10:57:00+08:00">2021-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">数据结构——栈</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入在一行中给出不含空格的中缀表达式，可包含+、-、*、\以及左右括号()，表达式不超过20个字符。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>2+3*(7-4)+8/4</p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>2 3 7 4 - * + 8 4 / +</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先读取整个中缀表达式，遍历整个表达式，当遇到操作数时，将操作数放入后缀表达式的字符串中；当遇到操作符时，如果栈为空，则入栈；如果栈不为空，就比较当前操作符和栈顶操作符的优先级，如果当前操作符优先级高，就压入栈中，如果相等，则将栈顶元素出栈(默认只有左右括号为相等)，如果当前操作符的优先级低，则将栈顶元素出栈，并且放入后缀表达式中，重复这个操作，直到这个运算符压入栈中，或者与左括号匹配时停止循环。重复读取判断直到整个表达式读取完毕，最后将栈中元素全都放入后缀表达式字符串中即可。<br>注意点：当操作数不为整数，或者操作数前存在正负号时，需要特殊处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;, <span class="keyword">char</span>&gt; mp =   <span class="comment">//优先级表</span></span><br><span class="line">&#123;	</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;=&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;-&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string inorder,postorder;</span><br><span class="line">    cin &gt;&gt; inorder;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(inorder[i]) || inorder[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || inorder[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>) || inorder[i] == <span class="string">&#x27;+&#x27;</span> </span><br><span class="line">        &amp;&amp; (i == <span class="number">0</span> || inorder[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>))&#123;  <span class="comment">//如果是数字，或者是数字前面的正负号</span></span><br><span class="line">            <span class="keyword">if</span>(postorder != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                postorder += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] != <span class="string">&#x27;+&#x27;</span>)&#123;  <span class="comment">//数字前的＋不需要放入后缀表达式</span></span><br><span class="line">                postorder += inorder[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(inorder[i]) || inorder[i] == <span class="string">&#x27;.&#x27;</span>)&#123;  <span class="comment">//将整个操作数放入后缀表达式中</span></span><br><span class="line">                postorder += inorder[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//操作符的情况</span></span><br><span class="line">            <span class="keyword">if</span>(op.<span class="built_in">empty</span>())&#123;  <span class="comment">//栈为空则直接压入</span></span><br><span class="line">                op.<span class="built_in">push</span>(inorder[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//栈不空，需要进行优先级判断</span></span><br><span class="line">                <span class="keyword">char</span> comp = mp[&#123;op.<span class="built_in">top</span>(),inorder[i]&#125;];</span><br><span class="line">                <span class="keyword">if</span>(comp == <span class="string">&#x27;&lt;&#x27;</span>)&#123;  <span class="comment">//当前元素优先级高，则直接压入栈中</span></span><br><span class="line">                    op.<span class="built_in">push</span>(inorder[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(comp == <span class="string">&#x27;=&#x27;</span>)&#123;  <span class="comment">//当前元素优先级等于栈顶元素优先级(左右括号)，则直接将左括号出栈</span></span><br><span class="line">                    op.<span class="built_in">pop</span>();</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;   <span class="comment">//当前元素优先级低</span></span><br><span class="line">                    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>() &amp;&amp; mp[&#123;op.<span class="built_in">top</span>(),inorder[i]&#125;] == <span class="string">&#x27;&gt;&#x27;</span>)&#123;  </span><br><span class="line">                        <span class="comment">//当栈不空且当前元素优先级低于栈顶元素时，将栈顶元素出栈并且放入后缀表达式中</span></span><br><span class="line">                        <span class="keyword">if</span>(postorder != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                            postorder += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        postorder += op.<span class="built_in">top</span>();</span><br><span class="line">                        op.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>())&#123;  <span class="comment">//将栈中所有运算符放入后缀表达式中</span></span><br><span class="line">        <span class="keyword">if</span>(postorder != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            postorder += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder += op.<span class="built_in">top</span>();</span><br><span class="line">        op.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; postorder;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" class="post-title-link" itemprop="url">前缀表达式求值(PTA 数据结构(中文) 7-21)</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-14 10:57:00 / 修改时间：14:52:14" itemprop="dateCreated datePublished" datetime="2021-11-14T10:57:00+08:00">2021-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">数据结构——栈</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前缀表达式求值"><a href="#前缀表达式求值" class="headerlink" title="前缀表达式求值"></a>前缀表达式求值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。</p>
<h2 id="Input-Example"><a href="#Input-Example" class="headerlink" title="Input Example"></a>Input Example</h2><p>+ + 2 * 3 - 7 4 / 8 4</p>
<h2 id="Output-Example"><a href="#Output-Example" class="headerlink" title="Output Example"></a>Output Example</h2><p>13.0</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从后往前读取前缀表达式，将读到的元素存到一个临时的字符串中，读到空格或者字符串最前面时停止。处理当前读到的字符串时，如果是数字，就压入栈中；如果是运算符，就取出栈中的两个元素(不足两个元素则错误)，与该运算符进行运算，再将结果压入栈中。重复操作，直到整个表达式处理完毕。最后如果栈中只剩一个元素，则输出结果，否则表达式错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2,<span class="keyword">char</span> op)</span></span>&#123;  <span class="comment">//表达式求值</span></span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num2 == <span class="number">0</span>)&#123;  <span class="comment">//除数为0</span></span><br><span class="line">            <span class="keyword">return</span> DBL_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1 / num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DBL_MIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string preorder;</span><br><span class="line">    <span class="built_in">getline</span>(cin,preorder);</span><br><span class="line">    <span class="keyword">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="keyword">double</span>&gt; stk;</span><br><span class="line">    set&lt;<span class="keyword">char</span>&gt; opset = &#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = n<span class="number">-1</span>;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;  <span class="comment">//临时字符串，用来存当前元素</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;  <span class="comment">//判断是数字还是操作符，数字为1，操作符为0</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; preorder[i] != <span class="string">&#x27; &#x27;</span>)&#123;  <span class="comment">//读取一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                flag = <span class="built_in">isdigit</span>(preorder[i]) ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            s += preorder[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;  <span class="comment">//数字</span></span><br><span class="line">            <span class="keyword">double</span> num = <span class="built_in">stod</span>(s);</span><br><span class="line">            stk.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//操作符</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; opset.<span class="built_in">find</span>(s[<span class="number">0</span>]) != opset.<span class="built_in">end</span>())&#123;  <span class="comment">//正确的操作符</span></span><br><span class="line">                <span class="keyword">char</span> op = s[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">double</span> num1 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">double</span> num2 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">double</span> res = <span class="built_in">Calculate</span>(num1,num2,op);</span><br><span class="line">                <span class="keyword">if</span>(res == DBL_MIN)&#123;  <span class="comment">//结果出错</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(res);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; preorder[i] == <span class="string">&#x27; &#x27;</span>)&#123;  <span class="comment">//处理空格</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stk.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; stk.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%BA%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%BA%E6%A0%91/" class="post-title-link" itemprop="url">表达式建树</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-14 10:57:00 / 修改时间：17:45:53" itemprop="dateCreated datePublished" datetime="2021-11-14T10:57:00+08:00">2021-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="表达式建树"><a href="#表达式建树" class="headerlink" title="表达式建树"></a>表达式建树</h1><h2 id="前缀表达式建树"><a href="#前缀表达式建树" class="headerlink" title="前缀表达式建树"></a>前缀表达式建树</h2><p>一个正确的前缀表达式可以唯一确定一棵表达式树，前缀表达式也可以通过表达式树的先序遍历来获得。前缀表达式建树可以通过栈的方式，也可以通过递归的方式。</p>
<h3 id="利用栈建表达式树"><a href="#利用栈建表达式树" class="headerlink" title="利用栈建表达式树"></a>利用栈建表达式树</h3><p>从右往左读取前缀表达式的每个部分，如果是数字，就创建一个新的结点，并且压入栈中；如果是运算符，从栈中推出两个结点分别作为左子树和右子树，再将新创建的结点压入栈中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>()&#123;</span><br><span class="line">        data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string str)&#123;</span><br><span class="line">        data = str;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; opset = &#123;<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string preorder;</span><br><span class="line">    <span class="built_in">getline</span>(cin,preorder);   </span><br><span class="line">    <span class="keyword">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;  <span class="comment">//从后往前遍历表达式</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; preorder[i] != <span class="string">&#x27; &#x27;</span>)&#123;  <span class="comment">//读取每个部分到字符串s中</span></span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                flag = <span class="built_in">isdigit</span>(preorder[i]) ? <span class="number">1</span> : <span class="number">0</span>;  <span class="comment">//判断数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            s += preorder[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;  <span class="comment">//数字</span></span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s);</span><br><span class="line">            stk.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//操作符</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; opset.<span class="built_in">find</span>(s) != opset.<span class="built_in">end</span>())&#123;  <span class="comment">//正确的操作符</span></span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s);</span><br><span class="line">                node-&gt;left = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                node-&gt;right = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                stk.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; preorder[i] == <span class="string">&#x27; &#x27;</span>)&#123;  <span class="comment">//处理空格</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = stk.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用递归建表达式树"><a href="#利用递归建表达式树" class="headerlink" title="利用递归建表达式树"></a>利用递归建表达式树</h3><p>先将表达式中的各个部分分离出来，然后递归创建表达式树。idx是当前索引位置，每次都创建一个新的结点，如果是运算数，就直接返回当前结点；如果是运算符，就递归建立左子树和右子树，最后再返回当前结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>()&#123;</span><br><span class="line">        data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string str)&#123;</span><br><span class="line">        data = str;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; opset = &#123;<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">CreateTree</span><span class="params">(vector&lt;string&gt; v,<span class="keyword">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v[idx]);</span><br><span class="line">    <span class="keyword">if</span>(opset.<span class="built_in">find</span>(v[idx]) == opset.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(v,++idx);  <span class="comment">//递归建立左子树</span></span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(v,++idx);  <span class="comment">//递归建立右子树</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string preorder;</span><br><span class="line">    <span class="built_in">getline</span>(cin,preorder);   </span><br><span class="line">    <span class="keyword">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;  <span class="comment">//遍历表达式，读取每个部分</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            s += preorder[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        v.<span class="built_in">push_back</span>(s);</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    TreeNode* root = <span class="built_in">CreateTree</span>(v,idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀表达式建树"><a href="#后缀表达式建树" class="headerlink" title="后缀表达式建树"></a>后缀表达式建树</h2><p>后缀表达式和前缀表达式类似，只需要在代码上稍作修改即可。</p>
<h3 id="利用栈建立表达式树"><a href="#利用栈建立表达式树" class="headerlink" title="利用栈建立表达式树"></a>利用栈建立表达式树</h3><p>与前缀表达式不同的是，从左往右遍历表达式，在对运算符操作时，先推出的结点作为右子树，后推出的结点作为左子树，其他均与前缀表达式相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>()&#123;</span><br><span class="line">        data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string str)&#123;</span><br><span class="line">        data = str;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; opset = &#123;<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string postorder;</span><br><span class="line">    <span class="built_in">getline</span>(cin,postorder);   </span><br><span class="line">    <span class="keyword">int</span> n = postorder.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; postorder[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            s += postorder[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="built_in">isdigit</span>(s[s.<span class="built_in">size</span>()<span class="number">-1</span>]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s);</span><br><span class="line">            stk.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; opset.<span class="built_in">find</span>(s) != opset.<span class="built_in">end</span>())&#123;  <span class="comment">//正确的操作符</span></span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s);</span><br><span class="line">                node-&gt;right = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                node-&gt;left = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                stk.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; postorder[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = stk.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用递归建立表达式树"><a href="#利用递归建立表达式树" class="headerlink" title="利用递归建立表达式树"></a>利用递归建立表达式树</h3><p>与前缀表达式不同的是，从左往右遍历表达式，然后递归时从v的右侧开始递归，遇到运算符时先递归建立右子树，再递归建立左子树。其他部分与前缀表达式相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>()&#123;</span><br><span class="line">        data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string str)&#123;</span><br><span class="line">        data = str;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; opset = &#123;<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">CreateTree</span><span class="params">(vector&lt;string&gt; v,<span class="keyword">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v[idx]);</span><br><span class="line">    <span class="keyword">if</span>(opset.<span class="built_in">find</span>(v[idx]) == opset.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(v,--idx);</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(v,--idx);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string postorder;</span><br><span class="line">    <span class="built_in">getline</span>(cin,postorder);   </span><br><span class="line">    <span class="keyword">int</span> n = postorder.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; postorder[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            s += postorder[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        v.<span class="built_in">push_back</span>(s);</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; postorder[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    TreeNode* root = <span class="built_in">CreateTree</span>(v,idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中缀表达式建树"><a href="#中缀表达式建树" class="headerlink" title="中缀表达式建树"></a>中缀表达式建树</h2><h3 id="利用栈建立表达式树-1"><a href="#利用栈建立表达式树-1" class="headerlink" title="利用栈建立表达式树"></a>利用栈建立表达式树</h3><p>中缀表达式建树比前缀表达式和后缀表达式建树复杂一些，需要判断运算符的优先级。我们需要一个结点栈和一个运算符栈，我们从左往右遍历表达式，如果是数字或者是数字前的正负号，就读取这个数字的部分，并且创建新的结点，压入结点的栈中；如果是运算符，如果栈空则压入运算符栈，如果栈不空，则判断当前运算符和栈顶运算符的优先级。如果当前运算符的优先级高，则将当前运算符压入栈中；如果当前运算符优先级与栈顶运算符优先级相同(默认只有左右括号满足这种情况)，则将栈顶元素出栈；如果当前运算符的优先级低，则每当运算符栈顶元素优先级高于当前元素，就将运算符栈顶元素出栈，以这个运算符创建一个新的结点，然后从结点栈中取出两个结点，分别作为这个结点的右子树和左子树，最后再将这个结点压入结点栈中。随后重复这个判断，直到运算符栈顶元素的优先级不高于当前元素，再进行下一步操作。遍历了整个表达式之后，如果运算符栈不空，则取出栈顶运算符，创建一个新的结点，再从结点栈取出两个结点作为右子树和左子树，再将新结点压入结点栈中。重复这个操作直到运算符栈为空。最后结点栈只剩一个结点，这个结点就是表达式树的根结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>()&#123;</span><br><span class="line">        data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string str)&#123;</span><br><span class="line">        data = str;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;, <span class="keyword">char</span>&gt; mp =   <span class="comment">//优先级表</span></span><br><span class="line">&#123;	</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;&lt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;=&#x27;</span>&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;*&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="string">&#x27;-&#x27;</span>&#125;,&#123;&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; opset = &#123;<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    string inorder;</span><br><span class="line">    <span class="built_in">getline</span>(cin,inorder);   </span><br><span class="line">    <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;TreeNode*&gt; nodestk;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; opstk;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(inorder[i]) || inorder[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || inorder[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>))&#123;  <span class="comment">//如果是数字，或者是数字前面的正负号</span></span><br><span class="line">            s += inorder[i];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(inorder[i]) || inorder[i] == <span class="string">&#x27;.&#x27;</span>)&#123;  <span class="comment">//将整个操作数放入后缀表达式中</span></span><br><span class="line">                s += inorder[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s);</span><br><span class="line">            nodestk.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opset.<span class="built_in">find</span>(inorder[i]) != opset.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(opstk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                opstk.<span class="built_in">push</span>(inorder[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">char</span> comp = mp[&#123;opstk.<span class="built_in">top</span>(),inorder[i]&#125;];</span><br><span class="line">                <span class="keyword">if</span>(comp == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">                    opstk.<span class="built_in">push</span>(inorder[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(comp == <span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">                    opstk.<span class="built_in">pop</span>();</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!opstk.<span class="built_in">empty</span>() &amp;&amp; mp[&#123;opstk.<span class="built_in">top</span>(),inorder[i]&#125;] == <span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">char</span> op = opstk.<span class="built_in">top</span>();</span><br><span class="line">                        opstk.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">if</span>(nodestk.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                            cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        string s;</span><br><span class="line">                        s += op;</span><br><span class="line">                        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s);</span><br><span class="line">                        node-&gt;right = nodestk.<span class="built_in">top</span>();</span><br><span class="line">                        nodestk.<span class="built_in">pop</span>();</span><br><span class="line">                        node-&gt;left = nodestk.<span class="built_in">top</span>();</span><br><span class="line">                        nodestk.<span class="built_in">pop</span>();</span><br><span class="line">                        nodestk.<span class="built_in">push</span>(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!opstk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> op = opstk.<span class="built_in">top</span>();</span><br><span class="line">        opstk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(nodestk.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string s;</span><br><span class="line">        s += op;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s);</span><br><span class="line">        node-&gt;right = nodestk.<span class="built_in">top</span>();</span><br><span class="line">        nodestk.<span class="built_in">pop</span>();</span><br><span class="line">        node-&gt;left = nodestk.<span class="built_in">top</span>();</span><br><span class="line">        nodestk.<span class="built_in">pop</span>();</span><br><span class="line">        nodestk.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = nodestk.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/09/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="bjy">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code King's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/09/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="post-title-link" itemprop="url">homework - 判断二叉查找树</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-09 21:01:00 / 修改时间：21:43:53" itemprop="dateCreated datePublished" datetime="2021-11-09T21:01:00+08:00">2021-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">数据结构——树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="判断二叉树是否二叉查找树"><a href="#判断二叉树是否二叉查找树" class="headerlink" title="判断二叉树是否二叉查找树"></a>判断二叉树是否二叉查找树</h1><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><p>给定一颗二叉树，每个结点存储一个整数关键字，判断它是否二叉查找树。</p>
<h2 id="input"><a href="#input" class="headerlink" title="input:"></a>input:</h2><p>第一行是一个整数n,表示测试样例数，接着是n个样例。<br>每个样例的第一行是一个正整数m,表示二叉树的结点数， 接下来分别是二叉树关键字的先序遍历和中序遍历结果，两个关键字中间用空格分隔。</p>
<h2 id="output"><a href="#output" class="headerlink" title="output:"></a>output:</h2><p>对每个样例，如果是二叉查找树，则输出“Yes”，否则输出“No”, 每个输出结果占一行。</p>
<h2 id="input-example"><a href="#input-example" class="headerlink" title="input example"></a>input example</h2><p>2<br>2<br>1 3<br>3 1<br>3<br>2 1 3<br>1 2 3</p>
<h2 id="output-example"><a href="#output-example" class="headerlink" title="output example"></a>output example</h2><p>No<br>Yes</p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 <strong>1</strong></h2><p>读入前序遍历和中序遍历之后，通过递归建立相应的二叉搜索树，然后通过根结点的data大于左子树最大的data，小于右子树最小的data的方式，递归来判断这个二叉搜索树是否正确。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>()&#123;</span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> dt)&#123;</span><br><span class="line">        data = dt;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">CreateTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; v1,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,vector&lt;<span class="keyword">int</span>&gt; v2,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 &gt; r1 || l2 &gt; r2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v1[l1]);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v2[l2+i] == v1[l1])&#123;</span><br><span class="line">            idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(v1,l1+<span class="number">1</span>,l1+idx,v2,l2,l2+idx<span class="number">-1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(v1,l1+idx+<span class="number">1</span>,r1,v2,l2+idx+<span class="number">1</span>,r2);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left)&#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right)&#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JudgeBIT</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JudgeBIT</span>(root-&gt;left) &amp;&amp; <span class="built_in">JudgeBIT</span>(root-&gt;right) &amp;&amp; root-&gt;data &gt; <span class="built_in">getMax</span>(root-&gt;left) &amp;&amp; root-&gt;data &lt; <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JudgeBIT</span>(root-&gt;left) &amp;&amp; root-&gt;data &gt; <span class="built_in">getMax</span>(root-&gt;left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JudgeBIT</span>(root-&gt;right) &amp;&amp; root-&gt;data &lt; <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">In</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; pre[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; In[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        root = <span class="built_in">CreateTree</span>(pre,<span class="number">0</span>,n<span class="number">-1</span>,In,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="built_in">JudgeBIT</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 <strong>2</strong></h2><p>二叉搜索树最根本的性质是根结点左子树所有结点的值都要小于根结点的值，右子树所有结点的值都要大于根结点的值，并且左子树和右子树也都是一棵二叉搜索树。我们知道中序遍历的顺序是先访问左子树，再访问根结点，最后访问右子树。因此中序遍历得到的数字序列是递增排列的。我们可以根据这个性质来解决这个问题，只需要判断中序遍历的序列是否是递增的，就可以判断是否为二叉搜索树了。    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Pre</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">In</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; Pre[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; In[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(In[i] &lt; In[i<span class="number">-1</span>])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bjy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">bjy</p>
  <div class="site-description" itemprop="description">书山有路勤为径，学海无涯苦作舟</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/C0nF1D3nt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;C0nF1D3nt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      题库网站链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/" title="https:&#x2F;&#x2F;leetcode-cn.com" rel="noopener" target="_blank">LeetCode</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://codeforces.com/" title="http:&#x2F;&#x2F;codeforces.com" rel="noopener" target="_blank">Codeforces</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.luogu.com.cn/" title="https:&#x2F;&#x2F;www.luogu.com.cn" rel="noopener" target="_blank">洛谷</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://matrix.sysu.edu.cn/" title="https:&#x2F;&#x2F;matrix.sysu.edu.cn" rel="noopener" target="_blank">Matrix</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://pintia.cn/problem-sets?tab=0" title="https:&#x2F;&#x2F;pintia.cn&#x2F;problem-sets?tab&#x3D;0" rel="noopener" target="_blank">PTA</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bjy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">37k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">33 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
